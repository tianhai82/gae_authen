package gae_authen

import (
	"appengine/aetest"
	"strings"
	"time"
	//	"fmt"
	jwt "github.com/dgrijalva/jwt-go"
	"testing"
)

func TestCreateUser(t *testing.T) {
	c, err := aetest.NewContext(nil)
	if err != nil {
		t.Fatal(err)
	}
	defer c.Close()
	authen := NewAuthen(c, []byte("Ce7BTYq1Qm6wa2ZmHb6oNE8JPmj+BvxLFZUJprIByl0iS9OoxojJF8As33sXF5W5h5964suovxM9kWUp1IXIWw=="))

	//test create user
	user, err := authen.CreateUser("testUser", []byte("P@ssw0rd"))
	if err != nil {
		t.Error("error creating user. Err:", err)
	}
	if user != "testUser" {
		t.Error("username is wrong")
	}

	//test login with correct username and password
	_, err = authen.Login("testUser", []byte("P@ssw0rd"))
	if err != nil {
		t.Errorf("Problem login in with correct userid and password. %s", err.Error())
	}

	//test login with non existence username
	_, err = authen.Login("testuser", []byte("P@ssw0rd"))
	if serr, ok := err.(*UserNotFound); ok {
		t.Logf("Ok. UserNotFound error is return! Msg: %s", serr.Error())
	} else {
		t.Errorf("Non existence user is logging in but UserNotFound error is not return")
	}

	//test login with wrong password
	_, err = authen.Login("testUser", []byte("P@sswOrd"))
	if serr, ok := err.(*WrongPasswordError); ok {
		t.Logf("Ok. WrongPasswordError error is return! Msg: %s", serr.Error())
	} else {
		t.Errorf("Wrong password is tried but WrongPasswordError is not return")
	}
}
func TestGetJwtForUser(t *testing.T) {
	c, err := aetest.NewContext(nil)
	if err != nil {
		t.Fatal(err)
	}
	defer c.Close()
	authen := NewAuthen(c, []byte("Ce7BTYq1Qm6wa2ZmHb6oNE8JPmj+BvxLFZUJprIByl0iS9OoxojJF8As33sXF5W5h5964suovxM9kWUp1IXIWw=="))

	tokenString, err := authen.getJwtForUser("yinloo")
	if err != nil {
		t.Error("error signing. Err: ", err)
	}

	token, err := authen.ParseToken(tokenString)

	//Check if tokenString return by getJwtForUser is valid
	if err != nil {
		t.Errorf("Parsing tokenString generated by getJwtForUser returns error: %s", err.Error())
	}
	if token == nil {
		t.Error("Parsing token generated by getJwtForUser does not return a token")
	}
	if !token.Valid {
		t.Error("Parsing token generated by getJwtForUser does not return a VALID token")
	}

	//Check if invalid tokenString returns correct error and nil token
	token, err = authen.ParseToken(strings.Replace(tokenString, "e", "E", 1))
	if err == nil {
		t.Error("Parsing invalid tokenString returns no error")
	}
	if token != nil {
		t.Error("Parsing invalid tokenString still returns a token: %v", token)
	}

	//check if tokenString generated by a similar key is invalid when parsed
	token, err = authen.ParseToken(tokenString)
	newToken := jwt.New(jwt.SigningMethodHS512)
	newToken.Claims["username"] = token.Claims["username"]
	newToken.Claims["iss"] = token.Claims["iss"]
	newToken.Claims["iat"] = token.Claims["iat"]
	newToken.Claims["exp"] = token.Claims["exp"]
	newKey := []byte("Cf7BTYq1Qm6wa2ZmHb6oNE8JPmj+BvxLFZUJprIByl0iS9OoxojJF8As33sXF5W5h5964suovxM9kWUp1IXIWw==")
	newTokenString, signErr := newToken.SignedString(newKey)
	if signErr != nil {
		t.Errorf("problem signing with another key: %s", signErr.Error())
	}
	token2, err2 := authen.ParseToken(newTokenString)
	if err2 == nil {
		t.Error("Parsing tokenString generated by different key returns no error")
	}
	if token2 != nil {
		t.Error("Parsing tokenString generated by different key still returns a token: %v", token)
	}

	//check if expired token is invalid
	newToken = jwt.New(jwt.SigningMethodHS512)
	newToken.Claims["username"] = token.Claims["username"]
	newToken.Claims["iss"] = token.Claims["iss"]
	newToken.Claims["iat"] = time.Now().Add(time.Minute * -30).Unix()
	newToken.Claims["exp"] = time.Now().Unix()
	newTokenString, signErr = newToken.SignedString(authen.privateKey)
	time.Sleep(time.Second * 1)
	token2, err2 = authen.ParseToken(newTokenString)
	if err2 == nil {
		t.Error("Parsing expired tokenString returns no error")
	}
	if token2 != nil {
		t.Error("Parsing expired tokenString still returns a token: %v", token)
	}
}
